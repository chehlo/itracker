# Copilot Instructions for Investment Tracker

## Core Philosophy
- **Small functions with clear naming and single purpose**
- **Avoid code duplication** - extract reusable functions
- **Comments only for non-trivial logic** - if comment needed, function name is wrong
- **Maintenance-first, performance second** - optimize only when justified
- **Interfaces and tests first, implementation second**
- **Incremental testing** - each test assumes previous layer works
- **No scope creep** - finish current task before starting new ones
- **Each iteration must be commit-able and pass tests**

## JavaScript/Node.js Specific Preferences

### Function Style
```javascript
// GOOD - Small, clear purpose, descriptive name
const calculatePortfolioValue = (investments) => {
  return investments.reduce((total, inv) => total + inv.currentValue, 0);
};

// GOOD - Single responsibility 
const validateInvestmentData = (data) => {
  if (!data.name || !data.type) {
    throw new Error('Name and type required');
  }
};

// BAD - Multiple responsibilities
const processInvestment = (data) => {
  // validates AND saves AND calculates - too much
};
```

### Modern JavaScript Syntax
```javascript
// Use const/let, never var
const config = require('./config');
let currentValue = 0;

// Prefer arrow functions for callbacks
const activeInvestments = investments.filter(inv => inv.isActive);

// Use async/await, avoid callback hell
const createInvestment = async (data) => {
  const validated = validateInvestmentData(data);
  const result = await db.investments.create(validated);
  return result;
};
```

### Error Handling Pattern
```javascript
// Consistent error response format
const handleError = (error, operation) => {
  return {
    success: false,
    error: error.message,
    operation
  };
};

// Graceful async error handling
const safeAsyncOperation = async (operation) => {
  try {
    const result = await operation();
    return { success: true, data: result };
  } catch (error) {
    return handleError(error, operation.name);
  }
};
```

### API Response Format
```javascript
// Standard success response
{
  success: true,
  data: {...},
  meta: { count: 10, page: 1 } // optional
}

// Standard error response  
{
  success: false,
  error: "Clear error message",
  code: "VALIDATION_ERROR" // optional
}
```

### Database Patterns
```javascript
// Always use transactions for multi-step operations
const transferInvestment = async (fromPortfolio, toPortfolio, investmentId) => {
  const client = await db.getClient();
  try {
    await client.query('BEGIN');
    await removeFromPortfolio(client, fromPortfolio, investmentId);
    await addToPortfolio(client, toPortfolio, investmentId);
    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};

// Fetch only needed columns
const getPortfolioSummary = async (id) => {
  return db.query(
    'SELECT name, currency, created_at FROM portfolios WHERE id = $1',
    [id]
  );
};
```

### Testing Patterns
```javascript
// Incremental testing - each layer assumes previous works
describe('Portfolio API', () => {
  // Level 1: Database connectivity (run first)
  describe('Database Connection', () => {
    test('should connect successfully', async () => {
      const result = await db.query('SELECT 1');
      expect(result).toBeDefined();
    });
  });

  // Level 2: Data operations (assumes DB works)
  describe('Portfolio CRUD', () => {
    test('should create portfolio', async () => {
      const portfolio = await createPortfolio(validData);
      expect(portfolio.id).toBeDefined();
    });
  });

  // Level 3: API endpoints (assumes CRUD works)
  describe('API Endpoints', () => {
    test('POST /portfolios should return 201', async () => {
      const response = await request(app).post('/portfolios').send(validData);
      expect(response.status).toBe(201);
    });
  });
});
```

### File Organization Principles
- **Group by feature, not by type** (portfolio/ not controllers/)
- **Keep related files together** (routes, models, tests in same feature folder)
- **Separate concerns clearly** (config, business logic, presentation)
- **Use consistent naming** (camelCase for JS files, kebab-case for URLs)

### Import/Export Style
```javascript
// Default export for single-purpose modules
module.exports = PortfolioController;

// Named exports for utilities
module.exports = {
  validateEmail,
  hashPassword,
  generateToken
};

// Modern import syntax where supported
const { validateEmail } = require('../shared/validators');
```

### Avoid These Patterns
```javascript
// DON'T - Global state
let globalPortfolio; // Bad

// DON'T - Nested callbacks
getData(id, (err, data) => {
  processData(data, (err, result) => {
    saveData(result, (err, saved) => { // Callback hell
      // ...
    });
  });
});

// DON'T - Manual loops when array methods work
const names = [];
for (let i = 0; i < users.length; i++) {
  names.push(users[i].name);
}
// DO - Declarative
const names = users.map(user => user.name);
```

### Module Export Patterns - BE EXPLICIT
```javascript
// GOOD - Export an instance (already created)
const pool = createDatabasePool();
module.exports = pool;
// Usage: const db = require('./database'); // No extra ()

// GOOD - Export a factory function  
const createDatabasePool = () => { /* ... */ };
module.exports = createDatabasePool;
// Usage: const db = require('./database')(); // Needs ()

// BAD - Confusing pattern (avoid)
module.exports = createDatabasePool(); // Exports instance but name suggests function

// CLEAR NAMING - Match export type to name
// If exporting instance: module.exports = databasePool;
// If exporting factory: module.exports = createPool;

## Development Workflow
1. **Write interface/contract first** (function signature, expected input/output)
2. **Write test that uses the interface**
3. **Implement minimal code to make test pass**
4. **Refactor without changing interface**
5. **Commit when tests pass**

## Copilot Usage Tips
- Start files with descriptive comments about purpose
- Use clear, descriptive function names
- Open related files in editor tabs for context
- Accept suggestions incrementally, not entire blocks
